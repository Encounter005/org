:PROPERTIES:
:ID:       1d3e4e5a+1ab9+4bb5+9cac+e26573b171f2
:END:
#+title: 内存管理方式
#+STARTUP: overview


* 连续

** 单一连续分配

系统将用户区整体分配给一个进程单独使用，只适用于单道程序环境

+ 特点： 操作系统不能并发，CPU大量时间处于空闲状态
+ 优点： 无外部碎片，无需内存保护，安全性较高且比较容易实现
+ 缺点： 有内部碎片，存储器理由利用率低，操作系统效率低



**  固定分区分配

在初始化时将内存空间分割成固定大小的区域，当有程序需要运行时，系统从内存中寻找一片合适的空闲分区分配给该程序

数据结构：

| 分区号 | 大小（KB） | 起址 | 状态   |
|      1 |         32 |   32 | 已分配 |
|      2 |        128 |   64 | 未分配 |

+ 分区大小相等： 任何一个可以装下该程序的区域即可
+ 分区大小不相等： 常用策略是每次都选择可以装入该程序的最小分区

+ 优点： 不存在外部碎片且实现简单，是系统开销很小的一种多道程序系统内存分配方法
+ 缺点： 预先划分一些分区会导致大程序无法装入，会产生较多的内部碎片

+ 注意： 只有在系统初期就知道程序大小分布时，该方式才能发挥更好的效果

[[file:/home/encounter/org/roam/Operating-System/pic/固定分区分配.png]]

**  动态分区分配

当系统有待运行的程序时，再从内存中划分一块与程序大小相当的连续区域分配出去，因此系统中分区大小和数目是可变的

+ 随着时间推移，内存中产生的外部碎片会越来越多


*** 分配算法

**** 首次适应算法

是指将空闲分区按照地址升序排序，每一次都从头向后查找，在第一个足够容纳改程序的连续空间中划分出程序所需的空间

+ 优点： 保留了高地址的大连续空间，利于后续到来的大程序装入
+ 缺点：
  1. 频繁在低地址部分划分空间，容易在这部分留下较多的外部碎片。
  2. 每次查找都从低地址开始，查找开销偏大

**** 循环首次适应算法

是指将空闲分区按照地址升序排序，设置一个查找指针，指针从头向后查找，随后的每一次查找都从上次查找后指针停留位置开始

+ 优点：在一定程度上缓解首次适应算法的两个弊端
+ 缺点： 会将本可以保存在内存末尾的大空间区域分裂为小空闲区域，会造成缺少大空闲分区的情况

**** 最佳适应算法

将空闲分区按从小到大排序，依次查找，选择第一个可以容纳程序的空间分配出去
> 选取最小可以容纳程序的空间进行分配

+ 优点： 能留下更多大分区以满足大进程的需求
+ 缺点：
  1. 容易留下许多小空间分区，其外部碎片是最多的。
  2. 需要对空闲分区进行大小排序，开销大


**** 最坏适应算法

是指将空闲分区按从大到小排序，若最大空闲分区不够容纳程序，则分配失败

+ 优点： 可以减少外部碎片产生
+ 缺点：
  1. 是得内存中缺少大空闲分区。
  2. 需要对空闲分区按大小排序，开销大


* 非连续

是指将一个完整的程序分隔开，放入不相邻的分区中


** 分页式存储

*** 页面和物理块

- 页面：将一个进程的逻辑地址空间分成若干个大小相等的片
- 物理块： 将内存空间分成与页面相同大小的若干个存储块

在为进程分配内存时，以块为单位将进程中的若干个页分别装入多个可以不相邻的物理块。

*** 页面大小

- 页面太小： 可以使内存碎片减少，也会使每个进程占用比较多的页面，从而导致进程的页表过长，还会降低页面换进换出的效率
- 页面太大： 可以减少页表的长度，却又会使页内碎片增大

所以页面的大小一般是2的指数幂

*** 地址结构
| 页号 | 位移量 |


*** 页表

程序的文件的页面分配在内存中不相邻的分区中，需要页表来记录页面与页框的对应关系


*** 基本地址变换机构

页表放在哪？

- 系统设置一个页表寄存器来存放页表的起始地址。

进程需要访问某个逻辑地址，从逻辑地址到物理地址变换过程如下

1. 将逻辑地址的页号与页表长度做比较，如果页号大于页表，则越界

2. 如果没有越界，则通过页号在页表中定位到对应的页表项，再从页表项获取对应的页框（块）号

3. 最后将页框号和逻辑地址中的页内偏移量组合在一起，形成对应的物理地址



[[file:/home/encounter/org/roam/Operating-System/pic/页表转换.png]]


*** 具有快表的变换机构

CPU通过页表每存取一个数据时，都要两次访问内存。

1. 访问内存中的页表，找到指定页的物理块号
2. 从第一次所得地址获取数据

快表是系统在内存中设置一个具有并行查找能力的高速缓存来存储页表

- 由地址变换机构自动地将页号P送入高速缓存寄存器，并将此页号与缓存中的所有页号进行比较，若其中有与此匹配的页号，就表示所要访问的页表项在快表中

[[file:/home/encounter/org/roam/Operating-System/pic/快表转换.png]]


*** 二级和多级页表

内层页表是程序文件页的索引，外层页表是内层页表的索引，PCB中记录的内容也就相应更改为外层页表的起始地址

逻辑地址结构

| 页号目录 | 页号 | 页内偏移量 |

> 最高层的页表不大于一个页面


** 分段式存储

主要目的是为了满足用户在coding和使用上的多方面需求

- 分页式存储是有操作系统完成，对用户透明
- 分段式存储对用户是可见的

*** 地址结构

| 段号 | 段内地址 |

*** 段表

由于段与段之间的大小并不相等，所以想要记录一个段的信息必须要有两个变量，通常以段长和起始地址作为记录变量


*** 地址变换机构

1.  将逻辑地址的高位段号取出，与段表长做比较，段号大于表长则越界

2. 若没有越界，则找到相应段表项，将段长与逻辑地址低位的段内偏移量比较，若偏移量大于段长则越界

3. 若没有越界，则将段表项中的段起始地址与逻辑地址的段内偏移量组合起来，获得对应的物理地址

[[file:/home/encounter/org/roam/Operating-System/pic/段转换.png]]

*** 段的保护

1. 存取控制保护
   - 对进程段页进行访问权限设置

2. 地址越界保护


** 段页式存储

是分页式和分段式的结合。段页式存储先将进程空间分段，再对进程空间的每一段进行分页，所以进程空间被划分的最小单位仍是页，这些页属于进程的某一段

[[file:/home/encounter/org/roam/Operating-System/pic/段页式存储.png]]


*** 地址结构

| 段号 | 段内页号 | 页内地址 |

*** 地址变换机构

系统应有一个段表寄存器，指出作业的段表起始地址和段表长度

在进行地址变换时：

1. 用虚拟地址中的段号部分到段表中进行查询，获得该段号对应的页表首地址
2. 通过该首地址找到相应的页表
3. 用虚拟地址中的页号部分到页表中进行查询，获得该页号对应的内存块号
4. 使用该内存块与虚拟地址中页内偏移量拼接获得对应的物理地址


这会使得访问内存的次数增加了两倍，为了提高执行速度，有以下措施：

- 增设一个高速缓冲器，每次访问时，都必须同时利用段号和页号去检索高速缓存
  1. 如果找到匹配的表项，就可以直接获得相应页的物理块号，用来与页内地址一起形成物理地址
  2. 如果没有找到，那么就需要第三次访问内存
